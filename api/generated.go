// Package api provides primitives to interact the openapi HTTP API.
//
// This is an autogenerated file, any edits which you make here will be lost!
package api

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"io"
	"net/http"
	"strings"
	"time"
)

// ASymmetricKey defines component schema for ASymmetricKey.
type ASymmetricKey struct {
	Alg         *string    `json:"alg,omitempty"`
	CipherText  *string    `json:"cipherText,omitempty"`
	LegalEntity Identifier `json:"legalEntity"`
}

// ConsentId defines component schema for ConsentId.
type ConsentId struct {
	UUID       *string `json:"UUID,omitempty"`
	ExternalId *string `json:"externalId,omitempty"`
}

// ConsentRequestJobState defines component schema for ConsentRequestJobState.
type ConsentRequestJobState struct {
	ConsentId      ConsentId      `json:"consentId"`
	StateMachineId StateMachineId `json:"stateMachineId"`
}

// ConsentRequestState defines component schema for ConsentRequestState.
type ConsentRequestState struct {
	Attachments []string                   `json:"attachments"`
	ConsentId   ConsentId                  `json:"consentId"`
	Signatures  []PartyAttachmentSignature `json:"signatures"`
}

// Domain defines component schema for Domain.
type Domain string

// EventStreamSetting defines component schema for EventStreamSetting.
type EventStreamSetting struct {
	Epoch int64  `json:"epoch"`
	Topic string `json:"topic"`
}

// Identifier defines component schema for Identifier.
type Identifier string

// Metadata defines component schema for Metadata.
type Metadata struct {
	Domain                 []Domain        `json:"domain"`
	OrganisationSecureKeys []ASymmetricKey `json:"organisationSecureKeys"`
	Period                 Period          `json:"period"`
	SecureKey              SymmetricKey    `json:"secureKey"`
}

// NewConsentRequestState defines component schema for NewConsentRequestState.
type NewConsentRequestState struct {
	Attachment string   `json:"attachment"`
	ExternalId string   `json:"externalId"`
	Metadata   Metadata `json:"metadata"`
}

// PartyAttachmentSignature defines component schema for PartyAttachmentSignature.
type PartyAttachmentSignature struct {
	Attachment  string           `json:"attachment"`
	LegalEntity Identifier       `json:"legalEntity"`
	Signature   SignatureWithKey `json:"signature"`
}

// Period defines component schema for Period.
type Period struct {
	ValidFrom time.Time  `json:"validFrom"`
	ValidTo   *time.Time `json:"validTo,omitempty"`
}

// SignatureWithKey defines component schema for SignatureWithKey.
type SignatureWithKey struct {
	Data      string `json:"data"`
	PublicKey string `json:"publicKey"`
}

// StateMachineId defines component schema for StateMachineId.
type StateMachineId string

// SymmetricKey defines component schema for SymmetricKey.
type SymmetricKey struct {
	Alg string `json:"alg"`
	Iv  string `json:"iv"`
}

// Client which conforms to the OpenAPI3 specification for this service. The
// server should be fully qualified with shema and server, ie,
// https://deepmap.com.
type Client struct {
	Server string
	Client http.Client
}

// GetAttachmentBySecureHash request
func (c *Client) GetAttachmentBySecureHash(ctx context.Context, secureHash string) (*http.Response, error) {
	req, err := NewGetAttachmentBySecureHashRequest(c.Server, secureHash)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// NewConsentRequestState request with JSON body
func (c *Client) NewConsentRequestState(ctx context.Context, body NewConsentRequestState) (*http.Response, error) {
	req, err := NewNewConsentRequestStateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// AcceptConsentRequestState request with JSON body
func (c *Client) AcceptConsentRequestState(ctx context.Context, uuid string, body PartyAttachmentSignature) (*http.Response, error) {
	req, err := NewAcceptConsentRequestStateRequest(c.Server, uuid, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// FinalizeConsentRequestState request
func (c *Client) FinalizeConsentRequestState(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewFinalizeConsentRequestStateRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// InitEventStream request with JSON body
func (c *Client) InitEventStream(ctx context.Context, body EventStreamSetting) (*http.Response, error) {
	req, err := NewInitEventStreamRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// GetConsentRequestStateById request
func (c *Client) GetConsentRequestStateById(ctx context.Context, uuid string) (*http.Response, error) {
	req, err := NewGetConsentRequestStateByIdRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	return c.Client.Do(req)
}

// NewGetAttachmentBySecureHashRequest generates requests for GetAttachmentBySecureHash
func NewGetAttachmentBySecureHashRequest(server string, secureHash string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "secureHash", secureHash)
	if err != nil {
		return nil, err
	}

	queryURL := fmt.Sprintf("%s/api/attachment/%s", server, pathParam0)

	req, err := http.NewRequest("GET", queryURL, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewNewConsentRequestStateRequest generates requests for NewConsentRequestState with JSON body
func NewNewConsentRequestStateRequest(server string, body NewConsentRequestState) (*http.Request, error) {
	var bodyReader io.Reader

	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	return NewNewConsentRequestStateRequestWithBody(server, "application/json", bodyReader)
}

// NewNewConsentRequestStateRequestWithBody generates requests for NewConsentRequestState with non-JSON body
func NewNewConsentRequestStateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryURL := fmt.Sprintf("%s/api/consent/consent_request", server)

	req, err := http.NewRequest("POST", queryURL, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewAcceptConsentRequestStateRequest generates requests for AcceptConsentRequestState with JSON body
func NewAcceptConsentRequestStateRequest(server string, uuid string, body PartyAttachmentSignature) (*http.Request, error) {
	var bodyReader io.Reader

	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	return NewAcceptConsentRequestStateRequestWithBody(server, uuid, "application/json", bodyReader)
}

// NewAcceptConsentRequestStateRequestWithBody generates requests for AcceptConsentRequestState with non-JSON body
func NewAcceptConsentRequestStateRequestWithBody(server string, uuid string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryURL := fmt.Sprintf("%s/api/consent/consent_request/%s/accept", server, pathParam0)

	req, err := http.NewRequest("POST", queryURL, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewFinalizeConsentRequestStateRequest generates requests for FinalizeConsentRequestState
func NewFinalizeConsentRequestStateRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryURL := fmt.Sprintf("%s/api/consent/consent_request/%s/finalize", server, pathParam0)

	req, err := http.NewRequest("POST", queryURL, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewInitEventStreamRequest generates requests for InitEventStream with JSON body
func NewInitEventStreamRequest(server string, body EventStreamSetting) (*http.Request, error) {
	var bodyReader io.Reader

	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)

	return NewInitEventStreamRequestWithBody(server, "application/json", bodyReader)
}

// NewInitEventStreamRequestWithBody generates requests for InitEventStream with non-JSON body
func NewInitEventStreamRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryURL := fmt.Sprintf("%s/api/consent/event_stream", server)

	req, err := http.NewRequest("POST", queryURL, body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetConsentRequestStateByIdRequest generates requests for GetConsentRequestStateById
func NewGetConsentRequestStateByIdRequest(server string, uuid string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParam("simple", false, "uuid", uuid)
	if err != nil {
		return nil, err
	}

	queryURL := fmt.Sprintf("%s/api/consent_request_state/%s", server, pathParam0)

	req, err := http.NewRequest("GET", queryURL, nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file.
func GetSwagger() (*openapi3.Swagger, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	swagger, err := openapi3.NewSwaggerLoader().LoadSwaggerFromData(buf.Bytes())
	if err != nil {
		return nil, fmt.Errorf("error loading Swagger: %s", err)
	}
	return swagger, nil
}

